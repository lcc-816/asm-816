

%start_symbol  program

%include {
#include <string>
#include <memory>
#include <stdexcept>
#include <cstdint>
#include <cassert>

#include "cxx/variant.h"


#include "Machine.h"
#include "Instruction.h"
#include "Expression.h"
#include "common.h"
#include "cookie.h"
#include "dp_register.h"

	extern void error(const std::string &, Cookie &);
	extern void warn(const std::string &, Cookie &);

#define error(x) error(x, *cookie)
#define warn(x) warn(x, *cookie)


}

%extra_argument {Cookie *cookie}
%token_type {Token}
%default_type {int}
%token_prefix tk

// allow X, Y, Z to be used as identifiers if appropriate.
%fallback IDENTIFIER REGISTER_X REGISTER_Y REGISTER_S REGISTER_Z.

%left PIPEPIPE.
%left AMPAMP.
%left PIPE.
%left CARET.
%left AMP.
%left EQEQ BANGEQ.
%left LT LTEQ GT GTEQ.  
%left LTLT GTGT.
%left PLUS MINUS. 
%left STAR SLASH PERCENT.
%right BANG TILDE.


%parse_failure {
	error("parse failure.");

	cookie->parse_error = 1;
}


%syntax_error {
	// TOKEN is the most recent token.

	fprintf(stderr, "--> %d: %s\n", yymajor, yyTokenName[yymajor]);

	error("syntax error.");
	cookie->syntax_error = true;
}


%parse_accept {
	//printf("parsing complete!\n");
}


%include {

	bool is_zp(AddressMode mode) {
		switch(mode) {
		case zp:
		case zp_x:
		case zp_y:
		case zp_indirect:
		case zp_indirect_x:
		case zp_indirect_y:
		case zp_relative: // bbr/bbs
		case zp_indirect_long:
		case zp_indirect_long_y:
			return true;
		default:
			return false;
		}
	}

	AddressMode to_zp(AddressMode mode) {
		switch(mode) {
		case absolute_long:
		case absolute:
			return zp;

		case absolute_long_x:
		case absolute_x:
			return zp_x;

		case absolute_y:
			return zp_y;

		case absolute_indirect:
			return zp_indirect;

		case absolute_indirect_x:
			return zp_indirect_x;

		case absolute_indirect_long:
			return zp_indirect_long;

			default:
				return mode;
		}
	}

	AddressMode to_abs(AddressMode mode) {
		switch(mode) {

		case zp:
		case absolute_long:
			return absolute;

		case zp_x:
		case absolute_long_x:
			return absolute_x;

		case zp_y:
			return absolute_y;

		case zp_indirect:
			return absolute_indirect;

		case zp_indirect_x:
			return absolute_indirect_x;

		case zp_indirect_long:
			return absolute_indirect_long;


		default:
			return mode;
		}
	}


	OpCode find_opcode(Instruction &instr, AddressMode mode, bool explicit_mode, ExpressionPtr e) {

		if (e && e->is_register() && mode != immediate) {
			if (!is_zp(mode)) {
				if (explicit_mode) {
					throw std::domain_error("Invalid address mode for dp register.");
				} else {
					mode = to_zp(mode);
				}
			}
		}

		uint32_t value;
		if (!explicit_mode && e->is_integer(value)) {
			if (value <= 256) {
				mode = to_zp(mode);
			}
		}

		bool ok = Instruction::coerce(instr, mode, explicit_mode);

		if (!ok) {
			throw std::domain_error("Invalid address mode for this instruction.");
			return OpCode();
		}

		return OpCode(instr, mode);
	}

	void Cookie::add_label(identifier label) {
		if (!label) return;
		if (!segment) return; // ?

		lines->emplace_back(BasicLine::Make(label));


		if (label->find('@') == label->npos)
			current_label = label;
	}

	void Cookie::begin_segment(identifier name, SegmentType type) {

		if (segment) {
			syntax_error = true;
			fprintf(stdout, "Error: Segment still active.\n");
			end_segment();
		}
		if (name == nullptr && type == data) {
			segment = data_segment.get();
		} else {
			segments.emplace_back(std::make_unique<Segment>());
			segment = segments.back().get();
			segment->name = name;
		}

		seg_type = type;
		lines = &segment->lines;
		equates.push();

		current_label = name;
	}

	void Cookie::end_segment() {
		if (!segment) {
			syntax_error = true;
			fprintf(stdout, "Error: No active segment.\n");
		} else {
			segment = nullptr;
			lines = nullptr;
			seg_type = none;
			equates.pop();
		}

		current_label = nullptr;
	}


}


program ::= .
program ::= line_list.

line_list ::= line.
line_list ::= line_list line.


line ::= opt_label(label) opcode(OP) EOL. {
	if (label) cookie->add_label(label);

	if (OP && cookie->segment) {
		// todo ... check warn if segment not active.
		cookie->lines->emplace_back(std::move(OP));
	}
}

line ::= opt_label(label) directive EOL. {
	if (label) cookie->add_label(label);
}


line ::= EOL.

line ::= IDENTIFIER(id) EOL. {
	cookie->add_label(id.string_value());
}

line ::= opt_label(label) START EOL. {
	cookie->begin_segment(label, Cookie::code);
}

/* anonymous or named data section */
line ::=  opt_label(label) DATA EOL. {
	cookie->begin_segment(label, Cookie::data);
}

	// opt_label?
line ::= END EOL. {
	cookie->end_segment();
}


line ::= IDENTIFIER(id) EQU expr(e) EOL. {
	// check if expr defined...
	// how to handle '*' ?

	cookie->equates.insert(id.string_value(), e->simplify());
}


%type opt_label {identifier}

opt_label(L) ::= . {
	L = nullptr;
}

opt_label(L) ::= IDENTIFIER(ID). {
	L = ID.string_value();
}



%type opcode {BasicLinePtr}

/* mvn or mvp  -- two parameters.*/
opcode(RV) ::= OPCODE_2(INSTR) expr(a) COMMA expr(b). {

	auto instr = INSTR.instruction_value();
	AddressMode mode;
	if (instr.hasAddressMode(block)) mode = block;
	if (instr.hasAddressMode(zp_relative)) mode = zp_relative;

	a = a->simplify();
	b = b->simplify();

	RV = BasicLine::Make(instr.mnemonic(), mode, std::move(a), std::move(b));
}

opcode(RV) ::= OPCODE(INSTR) operand(op). {

	AddressMode mode;
	bool explicit_mode;
	ExpressionPtr e;

	auto instr = INSTR.instruction_value();
	std::tie(mode, explicit_mode, e) = op;

	if (e) e = e->simplify();

	OpCode opcode;
	try { 
		opcode = find_opcode(instr, mode, explicit_mode, e);
	} catch(std::exception &e) {
		error(e.what());
	}
	RV = BasicLine::Make(opcode, std::move(e));
}

opcode(RV) ::= SMART_BRANCH(b) expr(e). {

	// operand vs expression... __bgt <xxx ?
	RV = BasicLine::Make(SMART_BRANCH, std::move(e));
	RV->branch = b.branch_value();
}

/* dc.b expression [, expression] */

opcode(RV) ::= DCB expr_list(e). {
	RV = BasicLine::Make(DCB, std::move(e));
}

opcode(RV) ::= DCW expr_list(e). {
	RV = BasicLine::Make(DCW, std::move(e));
}

opcode(RV) ::= DCL expr_list(e). {
	RV = BasicLine::Make(DCL, std::move(e));
}

opcode(RV) ::= DS expr(e). {
	RV = BasicLine::Make(DS, std::move(e));
}

opcode(RV) ::= ALIGN expr(e). {
	RV = BasicLine::Make(ALIGN, std::move(e));
}


directive ::= PRAGMA pragma_list. {
	if (!cookie->segment) 
		warn("PRAGMA outside of segment.");
}



pragma_list ::= pragma.
pragma_list ::= pragma_list COMMA pragma.


/*
 * segment = "string"
 * kind = int
 * locals = int
 * parameters = int
 * rts
 * databank
 */
pragma ::= SEGMENT EQ STRING(a). {
	if (cookie->segment) cookie->segment->segment = a.string_value();
}  
pragma ::= LOCALS EQ INTEGER(a). {
	if (cookie->segment) cookie->segment->local_size = a.int_value();
}
pragma ::= PARAMETERS EQ INTEGER(a). {
	if (cookie->segment) cookie->segment->parm_size = a.int_value();
}
pragma ::= RETURN EQ INTEGER(a). {
	if (cookie->segment) cookie->segment->return_size = a.int_value();
}
pragma ::= KIND EQ INTEGER(a). {
	if (cookie->segment) cookie->segment->kind = a.int_value();
}
pragma ::= PRIVATE. {
	// mark omf kind.
	if (cookie->segment) cookie->segment->kind |= 0x4000;
}
pragma ::= RTS. {
	if (cookie->segment) cookie->segment->rts = true;	
}

pragma ::= VOID. {
	if (cookie->segment) cookie->segment->return_size = 0;
}
pragma ::= CDECL. {
	if (cookie->segment) cookie->segment->convention = Segment::cdecl;	
}

pragma ::= STDCALL. {
	if (cookie->segment) cookie->segment->convention = Segment::stdcall;	
}

pragma ::= PASCAL. {
	if (cookie->segment) cookie->segment->convention = Segment::pascal;
}

pragma ::= NAKED. {
	if (cookie->segment) cookie->segment->convention = Segment::naked;
}

pragma ::= DYNAMIC. {
	if (cookie->segment) cookie->segment->dynamic = true;
}

pragma ::= DATABANK. {
	if (cookie->segment) cookie->segment->databank = true;
}


pragma ::= DEBUG. {
	if (cookie->segment) cookie->segment->debug = true;
}

directive ::= EXPORT export_list.
export_list ::= IDENTIFIER(a). {
	cookie->export_set.insert(a.string_value());
}

export_list ::= export_list COMMA IDENTIFIER(a). {
	cookie->export_set.insert(a.string_value());
}

directive ::= IMPORT import_list.
import_list ::= IDENTIFIER(a). {
	cookie->import_set.insert(a.string_value());
}

import_list ::= import_list COMMA IDENTIFIER(a). {
	cookie->import_set.insert(a.string_value());
}



opcode(RV) ::= FX_PROLOGUE. {
	RV = BasicLine::Make(PROLOGUE);
}

opcode(RV) ::= FX_EPILOGUE. {
	RV = BasicLine::Make(EPILOGUE);
}


%type expr_list {VectorExpressionPtr}

expr_list(rv) ::= expr(e). {
	rv = Expression::Vector();
	rv->push_back(std::move(e));
}

expr_list(rv) ::= expr_list(l) COMMA expr(e). {
	rv = std::move(l);
	rv->push_back(std::move(e));
}

%type operand{std::tuple<AddressMode, bool, ExpressionPtr>}

/* implied */
operand(rv) ::= . {
	rv = std::make_tuple(implied, true, ExpressionPtr());
}

/* #immediate */
operand(rv) ::= HASH expr(e). {
	rv = std::make_tuple(immediate, true, std::move(e));
}

/* relative, abs, abslong, etc */
operand(rv) ::= modifier(m) expr(e). {
	rv = std::make_tuple(m, true, std::move(e));
}

operand(rv) ::= expr(e). { 
	rv = std::make_tuple(absolute, false, std::move(e));
}

/* dp,x abs, x abslong,x etc */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_X. {

	AddressMode mode = m;

	switch(mode)
	{
	default: mode = absolute_long_x; break;

	case zp: mode = zp_x; break;
	case absolute: mode = absolute_x; break;
	case absolute_long: mode = absolute_long_x; break;
	}
	rv = std::make_tuple(mode, true, std::move(e));
}

operand(rv) ::= expr(e) COMMA REGISTER_X. {
	rv = std::make_tuple(absolute_x, false, std::move(e));
}

/* dp,y abs,y */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_Y. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_y; break;

	case zp: mode = zp_y; break;
	case absolute: mode = absolute_y; break;
	case absolute_long: 
		mode = absolute_y; 
		error("invalid address mode: >absolute long,y");
		break;

	}
	rv = std::make_tuple(mode, true, std::move(e));
}

operand(rv) ::= expr(e) COMMA REGISTER_Y. {
	rv = std::make_tuple(absolute_y, false, std::move(e));
}

/* (dp,x) (abs,x) */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_X RPAREN. {
	rv = std::make_tuple(absolute_indirect_x, false, std::move(e));
}

operand(rv) ::= LPAREN modifier(m) expr(e) COMMA REGISTER_X RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect_x; break;

	case zp: mode = zp_indirect_x; break;
	case absolute: mode = absolute_indirect_x; break;
	case absolute_long: 
		mode = absolute_indirect_x; 
		error("invalid address mode: (>absolute long,x)");
		break;
	}

	rv = std::make_tuple(mode, true, std::move(e));
}



/* (dp) (abs) */
operand(rv) ::= LPAREN expr(e) RPAREN. {
	rv = std::make_tuple(absolute_indirect, false, std::move(e));
}


operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect; break;

	case zp: mode = zp_indirect; break;
	case absolute: mode = absolute_indirect; break;
	case absolute_long: 
		mode = zp_indirect; 
		error("invalid address mode: (>absolute long)");
		break;
	}


	rv = std::make_tuple(mode, true, std::move(e));
}




/* (dp),y */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Y. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),y");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),y");
		break;
	}

	rv = std::make_tuple(zp_indirect_y, true, std::move(e));
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Y. {
	rv = std::make_tuple(zp_indirect_y, false, std::move(e));
}


/* 65ce02 -- just for fun! */
/* (dp),z */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Z. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),z");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),z");
		break;
	}

	rv = std::make_tuple(zp_indirect_z, true, std::move(e));
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Z. {
	rv = std::make_tuple(zp_indirect_z, false, std::move(e));
}



/* sr,s */
/* optional < ? */
operand(rv) ::= expr(e) COMMA REGISTER_S. {
	rv = std::make_tuple(stack_relative, false, std::move(e));
}

/* (sr,s),y */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_S RPAREN COMMA REGISTER_Y. {
	rv = std::make_tuple(stack_relative_y, false, std::move(e));
}

/* [dp] */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = zp_indirect_long; break;

	case zp: mode = zp_indirect_long; break;
	case absolute: mode = absolute_indirect_long; break;
	case absolute_long: 
		mode = absolute_indirect_long; 
		error("invalid address mode: [>absolute long]");
		break;
	}

	rv = std::make_tuple(mode, true, std::move(e));
}

operand(rv) ::= LBRACKET expr(e) RBRACKET. {
	rv = std::make_tuple(zp_indirect_long, false, std::move(e));
}

/* [dp],y */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET COMMA REGISTER_Y. {
	
	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: [|absolute],y");
		break;

	case absolute_long: 
		error("invalid address mode: [>absolute long],y");
		break;
	}
	rv = std::make_tuple(zp_indirect_long_y, true, std::move(e));
}

operand(rv) ::= LBRACKET expr(e) RBRACKET COMMA REGISTER_Y. {
	rv = std::make_tuple(zp_indirect_long_y, false, std::move(e));
}


/* modifier -  <, >, | */
%type modifier {AddressMode}
modifier(rv) ::= LT. { rv = zp; }
modifier(rv) ::= GT. { rv = absolute_long; }
modifier(rv) ::= PIPE. { rv = absolute; }

/* expressions */

%type expr {ExpressionPtr}
%type binary {ExpressionPtr}
%type unary {ExpressionPtr}
%type term {ExpressionPtr}
%type dp_register {ExpressionPtr}

expr(rv) ::= dp_register(a). { rv = a; }
expr(rv) ::= binary(a). { rv = a; }

binary(rv) ::= unary(a). { rv = a; }

binary(rv) ::= binary(a) PLUS binary(b). {
	rv = Expression::Binary('+', a, b);
}

binary(rv) ::= binary(a) MINUS binary(b). {
	rv = Expression::Binary('-', a, b);
}

binary(rv) ::= binary(a) STAR binary(b). {
	rv = Expression::Binary('*', a, b);
}

binary(rv) ::= binary(a) LTLT binary(b). {
	rv = Expression::Binary('<<', a, b);
}

binary(rv) ::= binary(a) GTGT binary(b). {
	rv = Expression::Binary('>>', a, b);
}

unary(rv) ::= PLUS unary(rhs). [BANG] {
	rv = rhs;
}
unary(rv) ::= MINUS unary(rhs). [BANG] {
	rv = Expression::Unary('-', rhs);
}

unary(rv) ::= CARET unary(rhs). [BANG] {
	rv = Expression::Unary('^', rhs);
}

unary(rv) ::= TILDE unary(rhs). [BANG] {
	rv = Expression::Unary('~', rhs);
}

unary(rv) ::= BANG unary(rhs). [BANG] {
	rv = Expression::Unary('!', rhs);
}

unary(rv) ::= term(a). { rv = std::move(a); }

term(rv) ::= IDENTIFIER(a). {
	rv = Expression::Identifier(a.string_value());
}

term(rv) ::= INTEGER(a). {
	rv = Expression::Integer(a.int_value());
}
term(rv) ::= STAR. {
	rv = Expression::PC();
}

term(rv) ::= EXPRESSION(a). {
	rv = a.expr_value();
}

dp_register(rv) ::= DP_REGISTER(a). {
	rv = Expression::Register(a.register_value());
}

dp_register(rv) ::= DP_REGISTER(a) PLUS INTEGER(n). {
	dp_register dp = a.register_value();
	dp.number += n.int_value();
	rv = Expression::Register(dp);
}


