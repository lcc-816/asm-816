

%start_symbol  program

%include {
#include <string>
#include <memory>
#include <stdexcept>
#include <cstdint>
#include <cassert>
#include <utility>

#include "cxx/variant.h"

#include "Machine.h"
#include "Instruction.h"
#include "Expression.h"
#include "common.h"
#include "cookie.h"
#include "dp_register.h"


#define LEMON_SUPER Parser
}

%token_type {Token}
%default_type {int}
%token_prefix tk

// allow X, Y, Z to be used as identifiers if appropriate.
%fallback IDENTIFIER REGISTER_X REGISTER_Y REGISTER_S REGISTER_Z REGISTER_A REGISTER_B REGISTER_K REGISTER_D.
%fallback IDENTIFIER SIGNED UNSIGNED CC.
%fallback IDENTIFIER OPCODE OPCODE_0 OPCODE_2.

%fallback IDENTIFIER DO WHILE IF.

%left PIPEPIPE.
%left AMPAMP.
%left PIPE.
%left CARET.
%left AMP.
%left EQEQ BANGEQ.
%left LT LTEQ GT GTEQ.  
%left LTLT GTGT.
%left PLUS MINUS. 
%left STAR SLASH PERCENT.
%right BANG TILDE.

%code {

	void Parser::begin_segment(identifier name, SegmentType type) {

		if (segment) {
			has_syntax_error = true;
			fprintf(stdout, "Error: Segment still active.\n");
			end_segment();
		}
		if (name == nullptr && type == data) {
			segment = data_segment.get();
		} else {
			segments.emplace_back(std::make_unique<Segment>());
			segment = segments.back().get();
			segment->name = name;
		}

		seg_type = type;
		equates.push();

		current_label = name;
	}

	void Parser::end_segment() {
		if (!segment) {
			has_syntax_error = true;
			fprintf(stdout, "Error: No active segment.\n");
		} else {

			segment->lines = std::move(lines);

			equates.pop();
		}

		segment = nullptr;
		lines.clear();
		seg_type = none;
		current_label = nullptr;
	}



	void Parser::add_label(identifier label, bool hidden) {
		if (!label) return;

		lines.emplace_back(BasicLine::Make(label));


		if (!hidden && label->find('@') == label->npos)
			current_label = label;
	}

	void Parser::add_line(BasicLinePtr &&line) {
		if (!line) return;
		lines.emplace_back(std::move(line));
	}

	void Parser::add_lines(std::vector<BasicLinePtr> &&lines) {
		for (auto &x : lines)
			if (x) lines.emplace_back(std::move(x));
	}


}


%include {

	bool is_zp(AddressMode mode) {
		switch(mode) {
		case zp:
		case zp_x:
		case zp_y:
		case zp_indirect:
		case zp_indirect_x:
		case zp_indirect_y:
		case zp_relative: // bbr/bbs
		case zp_indirect_long:
		case zp_indirect_long_y:
			return true;
		default:
			return false;
		}
	}

	AddressMode to_zp(AddressMode mode) {
		switch(mode) {
		case absolute_long:
		case absolute:
			return zp;

		case absolute_long_x:
		case absolute_x:
			return zp_x;

		case absolute_y:
			return zp_y;

		case absolute_indirect:
			return zp_indirect;

		case absolute_indirect_x:
			return zp_indirect_x;

		case absolute_indirect_long:
			return zp_indirect_long;

			default:
				return mode;
		}
	}

	AddressMode to_abs(AddressMode mode) {
		switch(mode) {

		case zp:
		case absolute_long:
			return absolute;

		case zp_x:
		case absolute_long_x:
			return absolute_x;

		case zp_y:
			return absolute_y;

		case zp_indirect:
			return absolute_indirect;

		case zp_indirect_x:
			return absolute_indirect_x;

		case zp_indirect_long:
			return absolute_indirect_long;


		default:
			return mode;
		}
	}


	OpCode find_opcode(Instruction &instr, AddressMode mode, bool explicit_mode, ExpressionPtr e) {

		if (e && e->is_register() && mode != immediate) {
			if (!is_zp(mode)) {
				if (explicit_mode) {
					throw std::domain_error("Invalid address mode for dp register.");
				} else {
					mode = to_zp(mode);
				}
			}
		}

		uint32_t value;
		if (!explicit_mode && e->is_integer(value)) {
			if (value <= 256) {
				mode = to_zp(mode);
			}
		}

		bool ok = Instruction::coerce(instr, mode, explicit_mode);

		if (!ok) {
			throw std::domain_error("Invalid address mode for this instruction.");
			return OpCode();
		}

		return OpCode(instr, mode);
	}

}

program ::= top_level .

top_level ::= .
top_level ::= top_level segment .
top_level ::= top_level record .
top_level ::= top_level tl_directive .

tl_directive ::= EOL.
tl_directive ::= error EOL.

tl_directive ::= EXPORT identifier_list(L). {
	for (auto &x : L) export_set.insert(x);	
}

tl_directive ::= IMPORT identifier_list(L). {
	for (auto &x : L) import_set.insert(x);		
}

tl_directive ::= LABEL(id) EQU expr(e). {
	equates.insert(id.string_value(), e->simplify());
}

nl ::= .
nl ::= EOL.

segment ::= segment_start segment_attr nl block . {
	end_segment();
}

record ::= record_start nl record_block. {
}

segment_attr ::= .
segment_attr ::= LPAREN nl RPAREN.
segment_attr ::= LPAREN nl attr_list nl RPAREN.
segment_attr ::= LPAREN error RPAREN.


attr_list ::= attr .
attr_list ::= attr_list COMMA nl attr .

%include {
	unsigned reparse_pragma(const std::string &s);
	char reparse_modifier(const std::string &s);
	#include "grammar.h"
}

attr ::= IDENTIFIER(ID). {
	const std::string &s = *ID.string_value();
	unsigned type = reparse_pragma(s);
	switch(type) {
	case 0:
		warn(std::string("Unknown pragma: ") + s);
		break;
	default:
		warn(std::string("Pragma requires a parameter: ") + s);
		break;
	case tkCDECL:
		segment->convention = Segment::cdecl;
		break;
	case tkPASCAL:
		segment->convention = Segment::pascal;
		break;
	case tkSTDCALL:
		segment->convention = Segment::stdcall;
		break;
	case tkNAKED:
		segment->convention = Segment::naked;
		break;
	case tkRTS:
		segment->rts = true;
		break;
	case tkRTL:
		segment->rts = false;
		break;
	case tkPRIVATE:
		segment->kind |= 0x4000;
		break;
	case tkVOID:
		segment->return_size = 0;
		break;
	case tkDYNAMIC:
		segment->dynamic = true;
		break;
	case tkDATABANK:
		segment->databank = true;
		break;
	case tkDEBUG:
		segment->debug = true;
		break;
	case tkVOLATILE:
		segment->has_volatile = true;
		break;
	case tkNORETURN:
		segment->noreturn = true;
		break;
	}	
}
attr ::= IDENTIFIER(ID) EQ STRING(S). {
	const std::string &s = *ID.string_value();
	unsigned type = reparse_pragma(s);
	switch(type) {
	case 0:
		warn(std::string("Unknown pragma: ") + s);
		break;
	default:
		warn(std::string("Pragma does not take a string parameter: ") + s);
		break;
	case tkSEGMENT:
		segment->segment = S.string_value();
		break;
	}
}

attr ::= IDENTIFIER(ID) EQ expr(e). {

	const std::string &s = *ID.string_value();
	unsigned type = reparse_pragma(s);

	e = e->simplify();
	uint32_t i;
	if (e->is_integer(i)) {

		switch(type) {
		case 0:
			warn(std::string("Unknown pragma: ") + s);
			break;
		default:
			warn(std::string("Pragma does not take a string parameter: ") + s);
			break;
		case tkLOCALS:
			segment->local_size = i;
			break;
		case tkPARAMETERS:
			segment->parm_size = i;
			break;
		case tkRETURN:
			segment->return_size = i;
			break;
		case tkKIND:
			segment->kind = i;
			break;
		}

	}
	else {
		warn(std::string("Expression too complex for pragma ") + s);
	}



}



%type opt_identifier {identifier}
opt_identifier ::= .
opt_identifier(RV) ::= IDENTIFIER(ID). { RV = ID.string_value(); }

segment_start ::= FUNCTION opt_identifier(name). {
	begin_segment(name, code);
}
segment_start ::= DATA opt_identifier(name). {
	begin_segment(name, data);
}


/*
 * records
 */
record_start ::= RECORD IDENTIFIER. {
}


record_block ::= LBRACKET record_block_lines RBRACKET.
record_block ::= LBRACKET error RBRACKET.


record_block_lines ::= record_block_line .
record_block_lines ::= record_block_lines EOL record_block_line.


record_block_line ::= error EOL .

record_block_line ::= .
record_block_line ::= LABEL.
record_block_line ::= LABEL EQU expr .
record_block_line ::= LABEL DS expr .
record_block_line ::= DS expr .


/*
 *
 */

block ::= LBRACKET block_lines RBRACKET.
block ::= LBRACKET error RBRACKET.

block_lines ::= block_line .
block_lines ::= block_lines EOL block_line.

block_line ::= error EOL .

block_line ::= LABEL(id) EQU expr(e). {

	// how to handle '*' ?
	equates.insert(id.string_value(), e->simplify());
	
}

block_line ::= opt_label opcode(OP). {
	add_line(std::move(OP));
}

block_line ::= opt_label block_opcode.
block_line ::= opt_label directive.

%type opt_label {void}

opt_label ::= .
opt_label ::= LABEL(id). {
	add_label(id.string_value());
}

block_opcode ::= .
block_opcode ::= if_stmt.
block_opcode ::= do_stmt.
block_opcode ::= while_stmt.


%type if_head {BasicLinePtr}

if_head(RV) ::= IF condition(C). {
	auto sym = gen_sym();

	auto b = BasicLine::Make(SMART_BRANCH, Expression::Identifier(sym));
	b->branch = branch{branch::invert(C), false};
	add_line(std::move(b));

	RV = BasicLine::Make(sym);
}

if_stmt ::= if_head(T) nl block. {
	add_line(std::move(T));
}

if_stmt ::= if_head(T) opcode(OP). {
	add_line(std::move(OP));
	add_line(std::move(T));
}

%type do_head {BasicLinePtr}

do_head(RV) ::= DO. {
	auto sym = gen_sym();
	add_label(sym, true);
	
	auto b = BasicLine::Make(SMART_BRANCH, Expression::Identifier(sym));
	b->branch = branch{branch::always, false};

	RV = std::move(b);
}

do_stmt ::= do_head(T) nl block nl WHILE condition(C). {

	T->branch = branch{C, false};
	add_line(std::move(T));
}

do_stmt ::= do_head(T) opcode(OP) WHILE condition(C). {

	add_line(std::move(OP));

	T->branch = branch{C, false};
	add_line(std::move(T));
}

%type while_head {std::pair<BasicLinePtr, BasicLinePtr>}

while_head(RV) ::= WHILE condition(C). {

	auto ssym = gen_sym();
	auto esym = gen_sym();

	add_label(ssym, true);

	auto b = BasicLine::Make(SMART_BRANCH, Expression::Identifier(esym));
	b->branch = branch{branch::invert(C), false};
	add_line(std::move(b));

	b = BasicLine::Make(SMART_BRANCH, Expression::Identifier(ssym));
	b->branch = branch{branch::always, false};

	RV = std::make_pair(std::move(b), BasicLine::Make(esym));
}

while_stmt ::= while_head(T) nl block. {

	add_line(std::move(T.first));
	add_line(std::move(T.second));

}

while_stmt ::= while_head(T) opcode(OP). {

	add_line(std::move(OP));

	add_line(std::move(T.first));
	add_line(std::move(T.second));
}

%type opcode {BasicLinePtr}
%type block {std::vector<BasicLinePtr> }

/* mvn or mvp  -- two parameters.*/
opcode(RV) ::= OPCODE_2(INSTR) expr(a) COMMA expr(b). {

	auto instr = INSTR.instruction_value();
	AddressMode mode;
	if (instr.hasAddressMode(block)) mode = block;
	if (instr.hasAddressMode(zp_relative)) mode = zp_relative;

	a = a->simplify();
	b = b->simplify();

	RV = BasicLine::Make(instr.mnemonic(), mode, std::move(a), std::move(b));
}

opcode(RV) ::= OPCODE_0(INSTR). {
	
	auto instr = INSTR.instruction_value();
	RV = BasicLine::Make(instr.mnemonic(), implied);
}

opcode(RV) ::= OPCODE(INSTR) operand(op). {

	AddressMode mode;
	bool explicit_mode;
	ExpressionPtr e;

	auto instr = INSTR.instruction_value();
	std::tie(mode, explicit_mode, e) = op;

	if (e) e = e->simplify();

	OpCode opcode;
	try { 
		opcode = find_opcode(instr, mode, explicit_mode, e);
	} catch(std::exception &e) {
		error(e.what());
	}
	RV = BasicLine::Make(opcode, std::move(e));
}

opcode(RV) ::= OPCODE(INSTR) REGISTER_A. {
	
	// inc a, dec a, etc.
	auto instr = INSTR.instruction_value();

	bool ok = false;
	switch (instr.mnemonic()) {
	case INC:
	case DEC:
	case ASL:
	case LSR:
	case ROL:
	case ROR:
		ok = true;
		break;
	default:
		break;
	}

	if (ok) {
		RV = BasicLine::Make(instr.mnemonic(), implied);
	} else {
		error("Invalid address mode.");
	}
}

opcode(RV) ::= OPCODE(INSTR) REGISTER_X. {

	// inc x -> inx

	auto instr = INSTR.instruction_value();

	switch (instr.mnemonic()) {
	case INC:
		RV = BasicLine::Make(INX, implied);
		break;
	case DEC:
		RV = BasicLine::Make(DEX, implied);
		break;
	default:
		error("Invalid address mode.");
		break;
	}
}

opcode(RV) ::= OPCODE(INSTR) REGISTER_Y. {

	// inc y -> iny

	auto instr = INSTR.instruction_value();

	bool ok = false;
	switch (instr.mnemonic()) {
	case INC:
		RV = BasicLine::Make(INY, implied);
		break;
	case DEC:
		RV = BasicLine::Make(DEY, implied);
		break;
	default:
		error("Invalid address mode.");
		break;
	}

	
}

opcode(RV) ::= BRANCH cc(c) COMMA expr(e). {

	RV = BasicLine::Make(SMART_BRANCH, std::move(e));
	RV->branch = branch{c, false};	
}

opcode(RV) ::= BRANCH expr(e). {
	// branch target
	RV = BasicLine::Make(SMART_BRANCH, std::move(e));
	RV->branch = branch{branch::always, false};	
}


block_opcode ::= PUSH push_list. 

push_list ::= push_item.
push_list ::= push_list COMMA push_item.

push_item ::= REGISTER_A. {
	add_line(BasicLine::Make(PHA, implied));
}

push_item ::= REGISTER_B. {
	add_line(BasicLine::Make(PHB, implied));
}

push_item ::= REGISTER_D. {
	add_line(BasicLine::Make(PHD, implied));
}

push_item ::= REGISTER_K. {
	add_line(BasicLine::Make(PHK, implied));
}

push_item ::= REGISTER_P. {
	add_line(BasicLine::Make(PHP, implied));
}

push_item ::= REGISTER_X. {
	add_line(BasicLine::Make(PHX, implied));
}

push_item ::= REGISTER_Y. {
	add_line(BasicLine::Make(PHY, implied));
}

push_item ::= REGISTER_Z. {
	add_line(BasicLine::Make(PHZ, implied));
}


push_item ::= HASH expr(e). {
	add_line(BasicLine::Make(PEA, absolute, std::move(e)));
}

push_item ::= dp_register(dp). {
	add_line(BasicLine::Make(PEI, zp_indirect, std::move(dp)));
}

block_opcode ::= PULL pull_list. 
pull_list ::= pull_item.
pull_list ::= pull_list COMMA pull_item.


pull_item ::= REGISTER_A. {
	add_line(BasicLine::Make(PLA, implied));
}

pull_item ::= REGISTER_B. {
	add_line(BasicLine::Make(PLB, implied));
}

pull_item ::= REGISTER_D. {
	add_line(BasicLine::Make(PLD, implied));
}

pull_item ::= REGISTER_P. {
	add_line(BasicLine::Make(PLP, implied));
}

pull_item ::= REGISTER_X. {
	add_line(BasicLine::Make(PLX, implied));
}

pull_item ::= REGISTER_Y. {
	add_line(BasicLine::Make(PLY, implied));
}

pull_item ::= REGISTER_Z. {
	add_line(BasicLine::Make(PLZ, implied));
}



%type cc {branch::branch_type}
%type condition {branch::branch_type}

condition(RV) ::= LPAREN cc(C) RPAREN. { RV = C; }

cc(RV) ::= CC(c). {
	RV = c.branch_value();
}

cc(RV) ::= BANG CC(c). {
	RV = branch::invert(c.branch_value());
}

cc(RV) ::= SIGNED CC(c). {
	RV = branch::make_signed(c.branch_value());
}

cc(RV) ::= UNSIGNED CC(c). {
	RV = c.branch_value();
}

cc(RV) ::= expr(e). {
	uint32_t i;
	e = e->simplify();
	if (e->is_integer(i)) {
		RV = i ? branch::always : branch::never;
	}
	else {
		error("Expression too complex for branch");
	}
}

opcode(RV) ::= SMART_BRANCH(b) expr(e). {

	// operand vs expression... __bgt <xxx ?
	RV = BasicLine::Make(SMART_BRANCH, std::move(e));
	RV->branch = branch{b.branch_value(), false};
}

/* dc.b expression [, expression] */

opcode(RV) ::= DC dc_modifier(M) expr_list(e). {
	//e = e->simplify();
	RV = BasicLine::Make(M, std::move(e));
}

%type dc_modifier {Directive}
dc_modifier(RV) ::= DOT IDENTIFIER(ID). {
	const std::string &s = *ID.string_value();

	int type = reparse_modifier(s);
	switch (type) {
	case 'b':
		RV = DCB;
		break;
	case 'w':
		RV = DCW;
		break;
	case 'l':
		RV = DCL;
		break;
	default:
		RV = DCW;
		error(std::string("Invalid modifier: ") + s);
		break;
	}
}

dc_modifier(RV) ::= . { RV = DCW; }


/*
opcode(RV) ::= DCW expr_list(e). {
	//e = e->simplify();
	RV = BasicLine::Make(DCW, std::move(e));
}

opcode(RV) ::= DCL expr_list(e). {
	//e = e->simplify();
	RV = BasicLine::Make(DCL, std::move(e));
}
*/

opcode(RV) ::= DS expr(e). {
	e = e->simplify();
	RV = BasicLine::Make(DS, std::move(e));
}

opcode(RV) ::= ALIGN expr(e). {
	e = e->simplify();
	RV = BasicLine::Make(ALIGN, std::move(e));
}


directive ::= PRAGMA pragma_list. {
	if (!segment) 
		warn("PRAGMA outside of segment.");
}



pragma_list ::= pragma.
pragma_list ::= pragma_list COMMA pragma.


/*
 * segment = "string"
 * kind = int
 * locals = int
 * parameters = int
 * rts
 * databank
 */
pragma ::= SEGMENT EQ STRING(a). {
	if (segment) segment->segment = a.string_value();
}  
pragma ::= LOCALS EQ INTEGER(a). {
	if (segment) segment->local_size = a.int_value();
}
pragma ::= PARAMETERS EQ INTEGER(a). {
	if (segment) segment->parm_size = a.int_value();
}
pragma ::= RETURN EQ INTEGER(a). {
	if (segment) segment->return_size = a.int_value();
}
pragma ::= KIND EQ INTEGER(a). {
	if (segment) segment->kind = a.int_value();
}
pragma ::= PRIVATE. {
	// mark omf kind.
	if (segment) segment->kind |= 0x4000;
}
pragma ::= RTS. {
	if (segment) segment->rts = true;	
}

pragma ::= RTL. {
	if (segment) segment->rts = false;	
}

pragma ::= VOID. {
	if (segment) segment->return_size = 0;
}
pragma ::= CDECL. {
	if (segment) segment->convention = Segment::cdecl;	
}

pragma ::= STDCALL. {
	if (segment) segment->convention = Segment::stdcall;	
}

pragma ::= PASCAL. {
	if (segment) segment->convention = Segment::pascal;
}

pragma ::= NAKED. {
	if (segment) segment->convention = Segment::naked;
}

pragma ::= DYNAMIC. {
	if (segment) segment->dynamic = true;
}

pragma ::= DATABANK. {
	if (segment) segment->databank = true;
}


pragma ::= DEBUG. {
	if (segment) segment->debug = true;
}

pragma ::= VOLATILE. {
	if (segment) segment->has_volatile = true;
}

pragma ::= NORETURN. {
	if (segment) segment->noreturn = true;
}


directive ::= EXPORT identifier_list(L). {
	for (auto &x : L) export_set.insert(x);	
}

directive ::= IMPORT identifier_list(L). {
	for (auto &x : L) import_set.insert(x);		
}

directive ::= STRONG identifier_list(L). {
	if (segment)
		segment->strong_vector.insert(segment->strong_vector.end(), L.begin(), L.end());
}

%type identifier_list { std::vector<identifier> }

identifier_list(RV) ::= IDENTIFIER(a). {
	RV.push_back(a.string_value());
}

identifier_list(RV) ::= identifier_list(L) COMMA IDENTIFIER(a). {
	RV = std::move(L);
	RV.push_back(a.string_value());
}


%type expr_list {VectorExpressionPtr}

expr_list(rv) ::= expr(e). {
	rv = Expression::Vector();
	rv->push_back(std::move(e));
}

expr_list(rv) ::= expr_list(l) COMMA expr(e). {
	rv = std::move(l);
	rv->push_back(std::move(e));
}

%type operand{std::tuple<AddressMode, bool, ExpressionPtr>}

/* implied */
operand(rv) ::= . {
	rv = std::make_tuple(implied, true, ExpressionPtr());
}

/* #immediate */
operand(rv) ::= HASH expr(e). {
	rv = std::make_tuple(immediate, true, std::move(e));
}

/* relative, abs, abslong, etc */
operand(rv) ::= modifier(m) expr(e). {
	rv = std::make_tuple(m, true, std::move(e));
}

operand(rv) ::= expr(e). { 
	rv = std::make_tuple(absolute, false, std::move(e));
}

/* dp,x abs, x abslong,x etc */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_X. {

	AddressMode mode = m;

	switch(mode)
	{
	default: mode = absolute_long_x; break;

	case zp: mode = zp_x; break;
	case absolute: mode = absolute_x; break;
	case absolute_long: mode = absolute_long_x; break;
	}
	rv = std::make_tuple(mode, true, std::move(e));
}

operand(rv) ::= expr(e) COMMA REGISTER_X. {
	rv = std::make_tuple(absolute_x, false, std::move(e));
}

/* dp,y abs,y */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_Y. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_y; break;

	case zp: mode = zp_y; break;
	case absolute: mode = absolute_y; break;
	case absolute_long: 
		mode = absolute_y; 
		error("invalid address mode: >absolute long,y");
		break;

	}
	rv = std::make_tuple(mode, true, std::move(e));
}

operand(rv) ::= expr(e) COMMA REGISTER_Y. {
	rv = std::make_tuple(absolute_y, false, std::move(e));
}

/* (dp,x) (abs,x) */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_X RPAREN. {
	rv = std::make_tuple(absolute_indirect_x, false, std::move(e));
}

operand(rv) ::= LPAREN modifier(m) expr(e) COMMA REGISTER_X RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect_x; break;

	case zp: mode = zp_indirect_x; break;
	case absolute: mode = absolute_indirect_x; break;
	case absolute_long: 
		mode = absolute_indirect_x; 
		error("invalid address mode: (>absolute long,x)");
		break;
	}

	rv = std::make_tuple(mode, true, std::move(e));
}



/* (dp) (abs) */
operand(rv) ::= LPAREN expr(e) RPAREN. {
	rv = std::make_tuple(absolute_indirect, false, std::move(e));
}


operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect; break;

	case zp: mode = zp_indirect; break;
	case absolute: mode = absolute_indirect; break;
	case absolute_long: 
		mode = zp_indirect; 
		error("invalid address mode: (>absolute long)");
		break;
	}


	rv = std::make_tuple(mode, true, std::move(e));
}




/* (dp),y */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Y. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),y");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),y");
		break;
	}

	rv = std::make_tuple(zp_indirect_y, true, std::move(e));
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Y. {
	rv = std::make_tuple(zp_indirect_y, false, std::move(e));
}


/* 65ce02 -- just for fun! */
/* (dp),z */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Z. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),z");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),z");
		break;
	}

	rv = std::make_tuple(zp_indirect_z, true, std::move(e));
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Z. {
	rv = std::make_tuple(zp_indirect_z, false, std::move(e));
}



/* sr,s */
/* optional < ? */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_S. {

	bool explicit_mode = true;
	AddressMode mode = stack_relative;

	switch (m) {
	case kUndefinedAddressMode:
	default:
		explicit_mode = false;
		break;

	case zp:
		break;

	case absolute:
		error("invalid address mode: |absolute,s");
		break;
	case absolute_long:
		error("invalid address mode: >absolute long,s");
		break;

	}
	rv = std::make_tuple(mode, explicit_mode, std::move(e));
}

operand(rv) ::= expr(e) COMMA REGISTER_S. {

	bool explicit_mode = false;
	AddressMode mode = stack_relative;


	rv = std::make_tuple(mode, explicit_mode, std::move(e));
}


/* (sr,s),y */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_S RPAREN COMMA REGISTER_Y. {

	bool explicit_mode = false;
	AddressMode mode = stack_relative_y;

	rv = std::make_tuple(stack_relative_y, false, std::move(e));
}

/* [dp] */
operand(rv) ::= LBRACKET opt_modifier(m) expr(e) RBRACKET. {

	AddressMode mode = zp_indirect_long;
	bool explicit_mode = false;

	switch(m)
	{
	case kUndefinedAddressMode:
	default:
		break;

	case zp:
		explicit_mode = true;
		break;

	case absolute:
		mode = absolute_indirect_long;
		explicit_mode = true;
		break;

	case absolute_long: 
		mode = absolute_indirect_long; 
		error("invalid address mode: [>absolute long]");
		break;
	}

	rv = std::make_tuple(mode, explicit_mode, std::move(e));
}

/*
operand(rv) ::= LBRACKET expr(e) RBRACKET. {
	rv = std::make_tuple(zp_indirect_long, false, std::move(e));
}
*/

/* [dp],y */
operand(rv) ::= LBRACKET opt_modifier(m) expr(e) RBRACKET COMMA REGISTER_Y. {

	AddressMode mode = zp_indirect_long_y;
	bool explicit_mode = false;

	switch(m)
	{
	case kUndefinedAddressMode:
	default:
		break;

	case zp:
		explicit_mode = true;
		break;

	case absolute: 
		error("invalid address mode: [|absolute],y");
		break;

	case absolute_long: 
		error("invalid address mode: [>absolute long],y");
		break;
	}
	rv = std::make_tuple(mode, explicit_mode, std::move(e));
}

/*
operand(rv) ::= LBRACKET expr(e) RBRACKET COMMA REGISTER_Y. {
	rv = std::make_tuple(zp_indirect_long_y, false, std::move(e));
}
*/

/* modifier -  <, >, | */
%type modifier {AddressMode}
modifier(rv) ::= LT. { rv = zp; }
modifier(rv) ::= GT. { rv = absolute_long; }
modifier(rv) ::= PIPE. { rv = absolute; }


%type opt_modifier {AddressMode}
opt_modifier(rv) ::= . { rv = kUndefinedAddressMode; }
opt_modifier(rv) ::= modifier(m). { rv = m; }


/* expressions */

%type expr {ExpressionPtr}
%type binary {ExpressionPtr}
%type unary {ExpressionPtr}
%type term {ExpressionPtr}
%type dp_register {ExpressionPtr}

expr(rv) ::= dp_register(a). { rv = a; }
expr(rv) ::= binary(a). { rv = a; }

binary(rv) ::= unary(a). { rv = a; }

binary(rv) ::= binary(a) PLUS binary(b). {
	rv = Expression::Binary('+', a, b);
}

binary(rv) ::= binary(a) MINUS binary(b). {
	rv = Expression::Binary('-', a, b);
}

binary(rv) ::= binary(a) STAR binary(b). {
	rv = Expression::Binary('*', a, b);
}

binary(rv) ::= binary(a) LTLT binary(b). {
	rv = Expression::Binary('<<', a, b);
}

binary(rv) ::= binary(a) GTGT binary(b). {
	rv = Expression::Binary('>>', a, b);
}

unary(rv) ::= PLUS unary(rhs). [BANG] {
	rv = rhs;
}
unary(rv) ::= MINUS unary(rhs). [BANG] {
	rv = Expression::Unary('-', rhs);
}

unary(rv) ::= CARET unary(rhs). [BANG] {
	rv = Expression::Unary('^', rhs);
}

unary(rv) ::= TILDE unary(rhs). [BANG] {
	rv = Expression::Unary('~', rhs);
}

unary(rv) ::= BANG unary(rhs). [BANG] {
	rv = Expression::Unary('!', rhs);
}

unary(rv) ::= term(a). { rv = std::move(a); }

term(rv) ::= IDENTIFIER(a). {
	rv = Expression::Identifier(a.string_value());
}

term(rv) ::= WEAK IDENTIFIER(a). {
	rv = Expression::WeakIdentifier(a.string_value());
}

term(rv) ::= INTEGER(a). {
	rv = Expression::Integer(a.int_value());
}
term(rv) ::= STAR. {
	rv = Expression::PC();
}

term(rv) ::= EXPRESSION(a). {
	rv = a.expr_value();
}

dp_register(rv) ::= DP_REGISTER(a). {
	rv = Expression::Register(a.register_value());
}

dp_register(rv) ::= DP_REGISTER(a) PLUS INTEGER(n). {
	dp_register dp = a.register_value();
	dp.number += n.int_value();
	rv = Expression::Register(dp);
}


%code {
	
	std::unique_ptr<Parser> Parser::make() {
		return std::make_unique<yypParser>();
	}

	void Parser::syntax_error(int yymajor, token_type &yyminor)
	{
		auto s = yyminor.string_value();
		fprintf(stderr, "--> %d: %s (%s)\n", yymajor, yyTokenName[yymajor], s ? s->c_str() : "");
		error("syntax error.");
		has_syntax_error = true;
	}


}

