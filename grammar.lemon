

%start_symbol  line

%include {
#include <string>
#include <memory>
#include <cstdint>
#include <cassert>

#include "Machine.h"
#include "Instruction.h"
#include "Expression.h"
#include "common.h"

	extern void error(const std::string &);
	extern void warn(const std::string &);



#define CopyExpression(a, b) a = b
}

%extra_argument {Cookie *cookie}
%token_type {Token}
%token_prefix tk


%left PIPEPIPE.
%left AMPAMP.
%left PIPE.
%left CARET.
%left AMP.
%left EQEQ BANGEQ.
%left LT LTEQ GT GTEQ.  
%left LTLT GTGT.
%left PLUS MINUS. 
%left STAR SLASH PERCENT.
%right BANG TILDE.

%parse_failure {
	error("parse error");

	cookie->scratch = Line();
}

%parse_accept {
	//printf("parsing complete!\n");

	cookie->scratch = Line();
}

%include {

	static void AddLine(Cookie *cookie) {
		Line *tmp = new Line(cookie->scratch);
		cookie->scratch = Line();

		if (cookie->tail) {
			cookie->tail->next = tmp;
			cookie->tail = tmp;
		} else {
			cookie->head = cookie->tail = tmp;
		}
	}
}

line ::= label EOL. {

	// add to list...
	AddLine(cookie);
}

line ::= label opcode EOL. {
	AddLine(cookie);
}

line ::= opcode EOL. {
	AddLine(cookie);
}

line ::= EOL. /* do nothing for blank lines */

/*
line ::= error EOL. {
	
	fprintf(stderr, "error encountered\n");
}

line ::= error. {
	
	fprintf(stderr, "error encountered\n");
}
*/


label ::= IDENTIFIER(id) COLON. {
	cookie->scratch.label = id.string_value;
}

/* mvn or mvp  -- two parameters.*/
opcode ::= OPCODE_2 expr(a) COMMA expr(b). {
	cookie->scratch.operands[0] = a;
	cookie->scratch.operands[1] = b;
}

opcode ::= OPCODE operand(op). {
	cookie->scratch.operands[0] = op;
}

%type operand {Expression *}

/* implied */
operand(rv) ::= . {
	cookie->scratch.mode = implied;
	CopyExpression(rv, nullptr);
}

/* #immediate */
operand(rv) ::= HASH expr(e). {
	cookie->scratch.mode = immediate;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

/* relative, abs, abslong, etc */
operand(rv) ::= modifier(m) expr(e). {
	cookie->scratch.mode = m;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= expr(a). { rv = a; }

/* dp,x abs, x abslong,x etc */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_X. {

	AddressMode mode = m;

	switch(mode)
	{
	default: mode = absolute_long_x; break;

	case zp: mode = zp_x; break;
	case absolute: mode = absolute_x; break;
	case absolute_long: mode = absolute_long_x; break;
	}
	cookie->scratch.explicit_mode = true;
	cookie->scratch.mode = mode;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_X. {
	cookie->scratch.mode = absolute_long_x;
	rv = e;
}

/* dp,y abs,y */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_Y. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_y; break;

	case zp: mode = zp_y; break;
	case absolute: mode = absolute_y; break;
	case absolute_long: 
		mode = absolute_y; 
		error("invalid address mode: >absolute long,y");
		break;

	}

	cookie->scratch.mode = mode;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_Y. {
	cookie->scratch.mode = absolute_y;
	rv = e;
}

/* (dp,x) (abs,x) */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_X RPAREN. {
	cookie->scratch.mode = absolute_indirect_x;
	rv = e;
}

operand(rv) ::= LPAREN modifier(m) expr(e) COMMA REGISTER_X RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect_x; break;

	case zp: mode = zp_indirect_x; break;
	case absolute: mode = absolute_indirect_x; break;
	case absolute_long: 
		mode = absolute_indirect_x; 
		error("invalid address mode: (>absolute long,x)");
		break;
	}

	cookie->scratch.mode = mode;
	cookie->scratch.explicit_mode = true;
	rv = e;
}



/* (dp) (abs) */
operand(rv) ::= LPAREN expr(e) RPAREN. {
	cookie->scratch.mode = absolute_indirect;
	rv = e;
}

/* (dp),y */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Y. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),y");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),y");
		break;
	}

	cookie->scratch.mode = zp_indirect_y;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Y. {
	cookie->scratch.mode = zp_indirect_y;
	rv = e;
}




/* sr,s */
/* optional < ? */
operand(rv) ::= expr(e) COMMA REGISTER_S. {
	cookie->scratch.mode = stack_relative;
	rv = e;
}

/* (sr,s),y */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_S RPAREN COMMA REGISTER_Y. {
	cookie->scratch.mode = stack_relative_y;
	rv = e;
}

/* [dp] */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = zp_indirect_long; break;

	case zp: mode = zp_indirect_long; break;
	case absolute: mode = absolute_indirect_long; break;
	case absolute_long: 
		mode = absolute_indirect_long; 
		error("invalid address mode: [>absolute long]");
		break;
	}

	cookie->scratch.mode = mode;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= LBRACKET expr(e) RBRACKET. {
	cookie->scratch.mode = zp_indirect_long;
	rv = e;
}

/* [dp],y */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET COMMA REGISTER_Y. {
	
	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: [|absolute],y");
		break;

	case absolute_long: 
		error("invalid address mode: [>absolute long],y");
		break;
	}

	cookie->scratch.mode = zp_indirect_long_y;
	cookie->scratch.explicit_mode = true;
	rv = e;	
}

operand(rv) ::= LBRACKET expr(e) RBRACKET COMMA REGISTER_Y. {
	cookie->scratch.mode = zp_indirect_long_y;
	rv = e;	
}


/* modifier -  <, >, | */
%type modifier {AddressMode}
modifier(rv) ::= LT. { rv = zp; }
modifier(rv) ::= GT. { rv = absolute_long; }
modifier(rv) ::= PIPE. { rv = absolute; }

/* expressions */

%type expr {Expression *}
%type binary {Expression *}
%type unary {Expression *}
%type term {Expression *}
%type dp_register {Expression *}

expr(rv) ::= dp_register(a). { rv = a; }
expr(rv) ::= binary(a). { rv = a; }

binary(rv) ::= unary(a). { rv = a; }

binary(rv) ::= binary(a) PLUS binary(b). {
	rv = Expression::Binary('+', a, b);
}

binary(rv) ::= binary(a) MINUS binary(b). {
	rv = Expression::Binary('-', a, b);
}

unary(rv) ::= PLUS unary(rhs). [BANG] {
	rv = rhs;
}
unary(rv) ::= MINUS unary(rhs). [BANG] {
	rv = Expression::Unary('-', rhs);
}

unary(rv) ::= CARET unary(rhs). [BANG] {
	rv = Expression::Unary('^', rhs);
}

unary(rv) ::= term(a). { rv = a; }

term(rv) ::= IDENTIFIER(a). {
	rv = Expression::Variable(a.string_value);
}

term(rv) ::= INTEGER(a). {
	rv = Expression::Integer(a.int_value);
}
term(rv) ::= STAR. {
	rv = Expression::PC();
}

dp_register(rv) ::= DP_REGISTER(a). {
	rv = Expression::Register(a.register_value);
}

dp_register(rv) ::= DP_REGISTER(a) PLUS INTEGER(n). {
	dp_register dp = a.register_value;
	dp.number += n.int_value;
	rv = Expression::Register(dp);
}


