
%start_symbol  line
%include {
#include <string>
#include <memory>
#include <cstdint>
#include "Machine.h"
#include "Instruction.h"

	#define CopyExpression(rv, e) new (&(rv)) ExpressionPtr(e)

	extern void error(const std::string &);
	extern void warn(const std::string &);

	class Expression;
	typedef std::shared_ptr<Expression> ExpressionPtr;

	struct {
	AddressMode mode;
	Instruction instruction;
	bool explicit_mode;
	const std::string *label;
	ExpressionPtr operands[2];
	} *cookie;

// add to YYMINORTYPE
/*
  YYMINORTYPE() { std::memset(this, 0, sizeof(*this)); }
  YYMINORTYPE(const YYMINORTYPE &rhs) { std::memcpy(this, &rhs, sizeof(*this)); }
  ~YYMINORTYPE();

  YYMINORTYPE& operator=(const YYMINORTYPE& rhs) {
    std::memcpy(this, &rhs, sizeof(*this));
    return *this;
  }
*/
	typedef struct Token {
		const std::string *string_value;
		uint32_t int_value;
	} Token;
}


   %token_type    {Token*}


line ::= label EOL.
line ::= label opcode EOL.
line ::= opcode EOL.
line ::= EOL.

//%type IDENTIFIER {const std::string *}
//%type INTEGER { uint32_t }

%type label {const std::string *}
label ::= IDENTIFIER(id) COLON. {
	cookie->label = id->string_value;
}

/* mvn or mvp  -- two parameters.*/
opcode ::= OPCODE_BLOCKMOVE expr(a) COMMA expr(b). {
	cookie->operands[0] = a;
	cookie->operands[1] = b;
}

opcode ::= OPCODE operand(op). {
	cookie->operands[0] = op;
}

%type operand {ExpressionPtr}
%destructor operand { $$.~ExpressionPtr(); }

/* implied */
operand(rv) ::= . {
	cookie->mode = implied;
	CopyExpression(rv, nullptr);
}
/* #immediate */
operand(rv) ::= HASH expr(e). {
	cookie->mode = immediate;
	cookie->explicit_mode = true;
	rv = e;
}

/* relative, abs, abslong, etc */
operand(rv) ::= modifier(m) expr(e). {
	cookie->mode = m;
	cookie->explicit_mode = true;
	rv = e;
}

operand ::= expr.

/* dp,x abs, x abslong,x etc */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_X. {

	AddressMode mode = m;

	switch(mode)
	{
	default: mode = absolute_long_x; break;

	case zp: mode = zp_x; break;
	case absolute: mode = absolute_x; break;
	case absolute_long: mode = absolute_long_x; break;
	}
	cookie->explicit_mode = true;
	cookie->mode = mode;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_X. {
	cookie->mode = absolute_long_x;
	rv = e;
}

/* dp,y abs,y */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_Y. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_y; break;

	case zp: mode = zp_y; break;
	case absolute: mode = absolute_y; break;
	case absolute_long: 
		mode = absolute_y; 
		error("invalid address mode: >absolute long,y");
		break;

	}

	cookie->mode = mode;
	cookie->explicit_mode = true;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_Y. {
	cookie->mode = absolute_y;
	rv = e;
}

/* (dp,x) (abs,x) */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_X RPAREN. {
	cookie->mode = absolute_indirect_x;
	rv = e;
}

operand(rv) ::= LPAREN modifier(m) expr(e) COMMA REGISTER_X RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect_x; break;

	case zp: mode = zp_indirect_x; break;
	case absolute: mode = absolute_indirect_x; break;
	case absolute_long: 
		mode = absolute_indirect_x; 
		error("invalid address mode: (>absolute long,x)");
		break;
	}

	cookie->mode = mode;
	cookie->explicit_mode = true;
	rv = e;
}



/* (dp) (abs) */
operand(rv) ::= LPAREN expr(e) RPAREN. {
	cookie->mode = absolute_indirect;
	rv = e;
}

/* (dp),y */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Y. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),y");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),y");
		break;
	}

	cookie->mode = zp_indirect_y;
	cookie->explicit_mode = true;
	rv = e;
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Y. {
	cookie->mode = zp_indirect_y;
	rv = e;
}




/* sr,s */
/* optional < ? */
operand(rv) ::= expr(e) COMMA REGISTER_S. {
	cookie->mode = stack_relative;
	rv = e;
}

/* (sr,s),y */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_S RPAREN COMMA REGISTER_Y. {
	cookie->mode = stack_relative_y;
	rv = e;
}

/* [dp] */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = zp_indirect_long; break;

	case zp: mode = zp_indirect_long; break;
	case absolute: mode = absolute_indirect_long; break;
	case absolute_long: 
		mode = absolute_indirect_long; 
		error("invalid address mode: [>absolute long]");
		break;
	}

	cookie->mode = mode;
	cookie->explicit_mode = true;
	rv = e;
}

operand(rv) ::= LBRACKET expr(e) RBRACKET. {
	cookie->mode = zp_indirect_long;
	rv = e;
}

/* [dp],y */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET COMMA REGISTER_Y. {
	
	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: [|absolute],y");
		break;

	case absolute_long: 
		error("invalid address mode: [>absolute long],y");
		break;
	}

	cookie->mode = zp_indirect_long_y;
	cookie->explicit_mode = true;
	rv = e;	
}

operand(rv) ::= LBRACKET expr(e) RBRACKET COMMA REGISTER_Y. {
	cookie->mode = zp_indirect_long_y;
	rv = e;	
}


/* modifier -  <, >, | */
%type modifier {AddressMode}
modifier(rv) ::= LT. { rv = zp; }
modifier(rv) ::= GT. { rv = absolute_long; }
modifier(rv) ::= PIPE. { rv = absolute; }

%type   expr  {ExpressionPtr}
%destructor expr { $$.~ExpressionPtr(); }

expr ::= dp_register.
expr ::= unary.


unary ::= PLUS unary.
unary ::= MINUS unary.
unary ::= CARET unary.
unary ::= term.

term ::= IDENTIFIER.
term ::= INTEGER.
term ::= STAR.

dp_register ::= DP_REGISTER.
dp_register(rv) ::= DP_REGISTER(dp) PLUS INTEGER(n). {
	dp.number += n->intValue;
	rv = dp;
}


