

%start_symbol  line

%include {
#include <string>
#include <memory>
#include <cstdint>
#include <cassert>

#include "Machine.h"
#include "Instruction.h"
#include "Expression.h"
#include "common.h"

	extern void error(const std::string &);
	extern void warn(const std::string &);



#define CopyExpression(a, b) a = b
}

%extra_argument {Cookie *cookie}
%token_type {Token}
%token_prefix tk


%left PIPEPIPE.
%left AMPAMP.
%left PIPE.
%left CARET.
%left AMP.
%left EQEQ BANGEQ.
%left LT LTEQ GT GTEQ.  
%left LTLT GTGT.
%left PLUS MINUS. 
%left STAR SLASH PERCENT.
%right BANG TILDE.

%parse_failure {
	error("parse error");

	cookie->scratch = Line();
}

%parse_accept {
	//printf("parsing complete!\n");

	cookie->scratch = Line();
}

%syntax_error {
	error("parse error.");
	// todo -- flag the line?
	// error should prevent further processing, anyhow.
}



%include {

	bool is_zp(AddressMode mode) {
		switch(mode) {
		case zp:
		case zp_x:
		case zp_y:
		case zp_indirect:
		case zp_indirect_x:
		case zp_indirect_y:
		case zp_relative: // bbr/bbs
		case zp_indirect_long:
		case zp_indirect_long_y:
			return true;
		default:
			return false;
		}
	}

	AddressMode to_zp(AddressMode mode) {
		switch(mode) {
		case absolute_long:
		case absolute:
			return zp;

		case absolute_long_x:
		case absolute_x:
			return zp_x;

		case absolute_y:
			return zp_y;

		case absolute_indirect:
			return zp_indirect;

		case absolute_indirect_x:
			return zp_indirect_x;

		case absolute_indirect_long:
			return zp_indirect_long;

			default:
				return mode;
		}
	}

	AddressMode to_abs(AddressMode mode) {
		switch(mode) {

		case zp:
		case absolute_long:
			return absolute;

		case zp_x:
		case absolute_long_x:
			return absolute_x;

		case zp_y:
			return absolute_y;

		case zp_indirect:
			return absolute_indirect;

		case zp_indirect_x:
			return absolute_indirect_x;

		case zp_indirect_long:
			return absolute_indirect_long;


		default:
			return mode;
		}
	}


	static void AddLine(Cookie *cookie) {


		Line &scratch = cookie->scratch;

		if (scratch.operands[0]) 
			scratch.operands[0] = scratch.operands[0]->simplify();

		if (scratch.operands[1]) 
			scratch.operands[1] = scratch.operands[1]->simplify();


		// 1. verify address mode.
		if (scratch.instruction) {

			Expression *e = scratch.operands[0];

			// dp_register is #immediate or <zp only.
			// immediate is explicit, though.

			if (e && e->is_register() && scratch.mode != immediate) {
				if (!is_zp(scratch.mode)) {
					if (scratch.explicit_mode) {
						error("Invalid address mode for dp register.");
					} else {
						scratch.mode = to_zp(scratch.mode);
					}
				}
			}

			// numeric arguments < 256 should be direct page.
			// immediate and implied have explicit_mode set.
			uint32_t value;
			if (!scratch.explicit_mode && scratch.operands[0]->is_integer(value)) {
				if (value >= 0 && value <= 256) {
					scratch.mode = to_zp(scratch.mode);
				}
			}

			bool ok = Instruction::coerce(scratch.instruction, 
				scratch.mode,  scratch.explicit_mode);

			if (!ok) {
				error("Invalid address mode for this instruction.");
				return;
			}

		}



		Line *tmp = new Line(cookie->scratch);
		cookie->scratch = Line();

		if (cookie->tail) {
			cookie->tail->next = tmp;
			cookie->tail = tmp;
		} else {
			cookie->head = cookie->tail = tmp;
		}
	}
}

line ::= label EOL. {
	// add to list...
	AddLine(cookie);
}

line ::= label opcode EOL. {
	AddLine(cookie);
}

line ::= opcode EOL. {
	AddLine(cookie);
}

line ::= EOL. /* do nothing for blank lines */

/*
line ::= error EOL. {
	
	fprintf(stderr, "error encountered\n");
}

line ::= error. {
	
	fprintf(stderr, "error encountered\n");
}
*/


label ::= IDENTIFIER(id) COLON. {
	cookie->scratch.label = id.string_value;
}

/* mvn or mvp  -- two parameters.*/
opcode ::= OPCODE_2 expr(a) COMMA expr(b). {

	if (cookie->scratch.instruction.hasAddressMode(block)) {
		cookie->scratch.mode = block;
	}

	if (cookie->scratch.instruction.hasAddressMode(zp_relative)) {
		cookie->scratch.mode = zp_relative;
	}


	cookie->scratch.operands[0] = a;
	cookie->scratch.operands[1] = b;
}

opcode ::= OPCODE operand(op). {
	cookie->scratch.operands[0] = op;
}

/* dc.b expression [, expression] */

opcode ::= DCB expr_list(list). {
	cookie->scratch.directive = DCB;
	cookie->scratch.operands[0] = list;	
}

opcode ::= DCW expr_list(list). {
	cookie->scratch.directive = DCW;
	cookie->scratch.operands[0] = list;	
}

opcode ::= DCL expr_list(list). {
	cookie->scratch.directive = DCL;
	cookie->scratch.operands[0] = list;	
}

%type expr_list {Expression *}

expr_list(rv) ::= expr(e). {
	Expression *tmp = Expression::Vector(e);
	rv = tmp;
}

expr_list(rv) ::= expr_list(l) COMMA expr(e). {
	l->append(e);
	rv = l;
}

%type operand {Expression *}

%include {
	

}


/* implied */
operand(rv) ::= . {
	cookie->scratch.mode = implied;
	cookie->scratch.explicit_mode = true;
	rv = nullptr;
}

/* #immediate */
operand(rv) ::= HASH expr(e). {
	cookie->scratch.mode = immediate;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

/* relative, abs, abslong, etc */
operand(rv) ::= modifier(m) expr(e). {
	cookie->scratch.mode = m;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= expr(e). { 
	cookie->scratch.mode = absolute_long;
	rv = e;
}

/* dp,x abs, x abslong,x etc */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_X. {

	AddressMode mode = m;

	switch(mode)
	{
	default: mode = absolute_long_x; break;

	case zp: mode = zp_x; break;
	case absolute: mode = absolute_x; break;
	case absolute_long: mode = absolute_long_x; break;
	}
	cookie->scratch.explicit_mode = true;
	cookie->scratch.mode = mode;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_X. {
	cookie->scratch.mode = absolute_long_x;
	rv = e;
}

/* dp,y abs,y */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_Y. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_y; break;

	case zp: mode = zp_y; break;
	case absolute: mode = absolute_y; break;
	case absolute_long: 
		mode = absolute_y; 
		error("invalid address mode: >absolute long,y");
		break;

	}

	cookie->scratch.mode = mode;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_Y. {
	cookie->scratch.mode = absolute_y;
	rv = e;
}

/* (dp,x) (abs,x) */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_X RPAREN. {
	cookie->scratch.mode = absolute_indirect_x;
	rv = e;
}

operand(rv) ::= LPAREN modifier(m) expr(e) COMMA REGISTER_X RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = absolute_indirect_x; break;

	case zp: mode = zp_indirect_x; break;
	case absolute: mode = absolute_indirect_x; break;
	case absolute_long: 
		mode = absolute_indirect_x; 
		error("invalid address mode: (>absolute long,x)");
		break;
	}

	cookie->scratch.mode = mode;
	cookie->scratch.explicit_mode = true;
	rv = e;
}



/* (dp) (abs) */
operand(rv) ::= LPAREN expr(e) RPAREN. {
	cookie->scratch.mode = absolute_indirect;
	rv = e;
}

/* (dp),y */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Y. {

	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),y");
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),y");
		break;
	}

	cookie->scratch.mode = zp_indirect_y;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Y. {
	cookie->scratch.mode = zp_indirect_y;
	rv = e;
}




/* sr,s */
/* optional < ? */
operand(rv) ::= expr(e) COMMA REGISTER_S. {
	cookie->scratch.mode = stack_relative;
	rv = e;
}

/* (sr,s),y */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_S RPAREN COMMA REGISTER_Y. {
	cookie->scratch.mode = stack_relative_y;
	rv = e;
}

/* [dp] */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET. {

	AddressMode mode = m;
	switch(mode)
	{
	default: mode = zp_indirect_long; break;

	case zp: mode = zp_indirect_long; break;
	case absolute: mode = absolute_indirect_long; break;
	case absolute_long: 
		mode = absolute_indirect_long; 
		error("invalid address mode: [>absolute long]");
		break;
	}

	cookie->scratch.mode = mode;
	cookie->scratch.explicit_mode = true;
	rv = e;
}

operand(rv) ::= LBRACKET expr(e) RBRACKET. {
	cookie->scratch.mode = zp_indirect_long;
	rv = e;
}

/* [dp],y */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET COMMA REGISTER_Y. {
	
	switch(m)
	{
	default: break;

	case zp: break;
	case absolute: 
		error("invalid address mode: [|absolute],y");
		break;

	case absolute_long: 
		error("invalid address mode: [>absolute long],y");
		break;
	}

	cookie->scratch.mode = zp_indirect_long_y;
	cookie->scratch.explicit_mode = true;
	rv = e;	
}

operand(rv) ::= LBRACKET expr(e) RBRACKET COMMA REGISTER_Y. {
	cookie->scratch.mode = zp_indirect_long_y;
	rv = e;	
}


/* modifier -  <, >, | */
%type modifier {AddressMode}
modifier(rv) ::= LT. { rv = zp; }
modifier(rv) ::= GT. { rv = absolute_long; }
modifier(rv) ::= PIPE. { rv = absolute; }

/* expressions */

%type expr {Expression *}
%type binary {Expression *}
%type unary {Expression *}
%type term {Expression *}
%type dp_register {Expression *}

expr(rv) ::= dp_register(a). { rv = a; }
expr(rv) ::= binary(a). { rv = a; }

binary(rv) ::= unary(a). { rv = a; }

binary(rv) ::= binary(a) PLUS binary(b). {
	rv = Expression::Binary('+', a, b);
}

binary(rv) ::= binary(a) MINUS binary(b). {
	rv = Expression::Binary('-', a, b);
}

unary(rv) ::= PLUS unary(rhs). [BANG] {
	rv = rhs;
}
unary(rv) ::= MINUS unary(rhs). [BANG] {
	rv = Expression::Unary('-', rhs);
}

unary(rv) ::= CARET unary(rhs). [BANG] {
	rv = Expression::Unary('^', rhs);
}

unary(rv) ::= term(a). { rv = a; }

term(rv) ::= IDENTIFIER(a). {
	rv = Expression::Variable(a.string_value);
}

term(rv) ::= INTEGER(a). {
	rv = Expression::Integer(a.int_value);
}
term(rv) ::= STAR. {
	rv = Expression::PC();
}

dp_register(rv) ::= DP_REGISTER(a). {
	rv = Expression::Register(a.register_value);
}

dp_register(rv) ::= DP_REGISTER(a) PLUS INTEGER(n). {
	dp_register dp = a.register_value;
	dp.number += n.int_value;
	rv = Expression::Register(dp);
}


