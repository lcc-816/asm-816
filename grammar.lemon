
%start_symbol  line


line ::= label EOL.
line ::= label opcode EOL.
line ::= opcode EOL.
line ::= EOL.

label ::= IDENTIFIER(id). {
	cookie->label = id;
}

/* mvn or mvp  -- two parameters.*/
opcode ::= OPCODE_BLOCKMOVE expr(a) COMMA expr(b). {
	cookie->operands[0] = a;
	cookie->operands[1] = b;
}

opcode ::= OPCODE operand(op). {
	cookie->operand[0] = op;
}

/* implied */
operand(rv) ::= . {
	cookie->mode = implied;
	rv = NULL;
}
/* #immediate */
operand(rv) ::= HASH expr(e). {
	cookie->mode = immediate;
	cookie->explicit_mode = true;
	rv = e;
}

/* relative, abs, abslong, etc */
operand(rv) ::= modifier(m) expr(e). {
	cookie->mode = m;
	cookie->explicit_mode = true;
	rv = e;
}

operand ::= expr.

/* dp,x abs, x abslong,x etc */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_X. {

	AddressMode mode = m;

	switch(mode)
	{
	case zp: mode = zp_x; break;
	case absolute: mode = absolute_x; break;
	case absolute_long: mode = absolute_long_x; break;
	}
	cookie->explicit_mode = true;
	cookie->mode = mode;
	rv = e;
}
operand ::= expr COMMA REGISTER_X. {
	cookie->mode = absolute_long_x;
	rv = e;
}

/* dp,y abs,y */
operand(rv) ::= modifier(m) expr(e) COMMA REGISTER_Y. {

	AddressMode mode = m;
	switch(mode)
	{
	case zp: mode = zp_y; break;
	case absolute: mode = absolute_y; break;
	case absolute_long: 
		mode = absolute_y; 
		error("invalid address mode: >absolute long,y")
		break;
	}

	cookie->mode = mode;
	cookie->explicit_mode = true;
	rv = e;
}

operand(rv) ::= expr(e) COMMA REGISTER_Y. {
	cookie->mode = absolute_y;
	rv = e;
}

/* (dp,x) (abs,x) */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_X RPAREN. {
	cookie->mode = absolute_indirect_x
	rv = e;
}

operand(rv) ::= LPAREN modifier(m) expr(e) COMMA REGISTER_X RPAREN. {

	AddressMode mode = m;
	switch(mode)
	{
	case zp: mode = zp_indirect_x; break;
	case absolute: mode = absolute_indirect_x; break;
	case absolute_long: 
		mode = absolute_indirect_x; 
		error("invalid address mode: (>absolute long,x)")
		break;
	}

	cookie->mode = mode;
	cookie->explicit_mode = true;
	rv = e;
}



/* (dp) (abs) */
operand(rv) ::= LPAREN expr(e) RPAREN. {
	cookie->mode = absolute_indirect;
	rv = e;
}

/* (dp),y */
operand(rv) ::= LPAREN modifier(m) expr(e) RPAREN COMMA REGISTER_Y. {

	switch(m)
	{
	case zp: break;
	case absolute: 
		error("invalid address mode: (|absolute),y")
		break;
	case absolute_long: 
		error("invalid address mode: (>absolute long),y")
		break;
	}

	cookie->mode = zp_indirect_y;
	cookie->explicit_mode = true;
	rv = e;
}

operand(rv) ::= LPAREN expr(e) RPAREN COMMA REGISTER_Y. {
	cookie->mode = zp_indirect_y;
	rv = e;
}




/* sr,s */
/* optional < ? */
operand(rv) ::= expr(e) COMMA REGISTER_S. {
	cookie->mode = stack_relative;
	rv = e;
}

/* (sr,s),y */
operand(rv) ::= LPAREN expr(e) COMMA REGISTER_S RPAREN COMMA REGISTER_Y. {
	cookie->mode = stack_relative_y;
	rv = e;
}

/* [dp] */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET. {

	AddressMode mode = m;
	switch(mode)
	{
	case zp: mode = zp_indirect_long; break;
	case absolute: mode = absolute_indirect_long; break;
	case absolute_long: 
		mode = absolute_indirect_long; 
		error("invalid address mode: [>absolute long]")
		break;
	}

	cookie->mode = mode;
	cookie->explicit_mode = true;
	rv = e;
}

operand(rv) ::= LBRACKET expr(e) RBRACKET. {
	cookie->mode = zp_indirect_long;
	rv = e;
}

/* [dp],y */
operand(rv) ::= LBRACKET modifier(m) expr(e) RBRACKET COMMA REGISTER_Y. {
	
	switch(m)
	{
	case zp: mode = break;
	case absolute: 
		error("invalid address mode: [|absolute],y")
		break;

	case absolute_long: 
		error("invalid address mode: [>absolute long],y")
		break;
	}

	cookie->mode = zp_indirect_long_y;
	cookie->explicit_mode = true;
	rv = e;	
}

operand(rv) ::= LBRACKET expr(e) RBRACKET COMMA REGISTER_Y. {
	cookie->mode = zp_indirect_long_y;
	rv = e;	
}


/* modifier -  <, >, | */
modifier(rv) ::= LT. { rv = zp; }
modifier(rv) ::= GT. { rv = abslong_long; }
modifier(rv) ::= PIPE. { rv = absolute; }


expr ::= dp_register.
expr ::= unary.


unary ::= PLUS unary.
unary ::= MINUS unary.
unary ::= CARET unary.
unary ::= term.

term ::= IDENTIFIER.
term ::= INTEGER.
term ::= STAR.

dp_register ::= DP_REGISTER.
dp_register(rv) ::= DP_REGISTER(dp) PLUS INTEGER(n). {
	dp.number += n;
	rv = dp;
}


